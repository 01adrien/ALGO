# ðŸ§  Plan 8 semaines â€” Skiena + LeetCode (pratique)

> Objectif : dÃ©velopper un mindset algorithmique et pratiquer intensivement sur LeetCode.
> Chaque semaine = lecture + exercices codÃ©s.

---

## ðŸŸ¦ Semaine 1 â€” Introduction & analyse dâ€™algos
**Skiena : Chapitres 1â€“2 (pages ~1â€“54)**

- 1. Introduction to Algorithm Design
  - Robot Tour Optimization, Job Selection, Modeling, Exercises
- 2. Algorithm Analysis
  - RAM model, Big-O, Growth Rates, Logarithms, Exercises



**LeetCode :**
- [ ] 78. Subsets
- [X] 136. Single Number
- [ ] 121. Best Time to Buy and Sell Stock
- [ ] 234. Palindrome Linked List
- [ ] 242. Valid Anagram
- [X] 169. Majority Element
- [ ] 125. Valid Palindrome
- [ ] 1365. How Many Numbers Are Smaller Than the Current Number
- [X] 217. Contains Duplicate
- [X] 202. Happy Number
- [ ] 119. Pascalâ€™s Triangle II
- [X] 20. Valid Parentheses
- [ ] 46. Permutations

**Objectif :**
- Comprendre le pattern dâ€™un problÃ¨me avant de coder.
- Savoir analyser la complexitÃ©.

---

## ðŸŸ¦ Semaine 2 â€” Structures de donnÃ©es de base
**Skiena : Chapitre 3.1â€“3.5 (pages ~65â€“85)**

- Contiguous vs Linked Data Structures
- Stacks & Queues
- Dictionaries
- Binary Search Trees
- Priority Queues

**LeetCode :**
- [ ] 1. Two Sum
- [ ] 242. Valid Anagram
- [ ] 155. Min Stack
- [ ] 380. Insert Delete GetRandom O(1)
- [ ] 146. LRU Cache

**Objectif :**
- Associer naturellement un problÃ¨me Ã  sa structure.

---

## ðŸŸ¦ Semaine 3 â€” Hashing, Strings & RÃ©cursion
**Skiena : Chapitre 3.6â€“3.10 (pages ~89â€“98)**

- Hashing and Strings
- Specialized Data Structures
- War Stories
- Exercises

**LeetCode :**
- [X] 394. Decode String
- [X] 224. Basic Calculator
- [ ] 1106. Parsing A Boolean Expression
- [ ] 1047. Remove All Adjacent Duplicates In String

**Objectif :**
- MaÃ®triser les piles et la rÃ©cursion pour parsing et string processing.

---

## ðŸŸ¦ Semaine 4 â€” Sorting & Searching
**Skiena : Chapitre 4 (pages ~103â€“139)**

- Heapsort, Mergesort, Quicksort, Distribution Sort
- Binary Search, Divide-and-Conquer
- Applications & Exercises

**LeetCode :**
- [ ] 49. Group Anagrams
- [ ] 238. Product of Array Except Self
- [ ] 53. Maximum Subarray
- [ ] 33. Search in Rotated Sorted Array
- [ ] 34. Find First and Last Position of Element in Sorted Array

**Objectif :**
- Comprendre quand trier simplifie un problÃ¨me.

---

## ðŸŸ¦ Semaine 5 â€” Graphes de base
**Skiena : Chapitre 5 (pages ~145â€“178)**

- Flavors of Graphs, Data Structures
- BFS / DFS + Applications
- Exercises

**LeetCode :**
- [ ] 200. Number of Islands
- [ ] 133. Clone Graph
- [ ] 207. Course Schedule
- [ ] 994. Rotting Oranges
- [ ] 797. All Paths From Source to Target

**Objectif :**
- Savoir reprÃ©senter et parcourir un graphe efficacement.

---

## ðŸŸ¦ Semaine 6 â€” Graphes pondÃ©rÃ©s & MST / Shortest Path
**Skiena : Chapitre 6 (pages ~192â€“225)**

- Minimum Spanning Trees
- Shortest Paths
- Network Flows
- Exercises

**LeetCode :**
- [ ] 1135. Connecting Cities With Minimum Cost
- [ ] 743. Network Delay Time
- [ ] 787. Cheapest Flights Within K Stops

**Objectif :**
- Approfondir les graphes pondÃ©rÃ©s et algos classiques.

---

## ðŸŸ¦ Semaine 7 â€” Backtracking & Dynamic Programming
**Skiena : Chapitre 7â€“8 (pages ~230â€“310)**

- Backtracking & heuristics
- DP : Caching, LIS, Partition, Knapsack, Parsing CFGs
- Exercises

**LeetCode :**
- [ ] 46. Permutations
- [ ] 78. Subsets
- [ ] 300. Longest Increasing Subsequence
- [ ] 416. Partition Equal Subset Sum
- [ ] 198. House Robber

**Objectif :**
- Sâ€™entraÃ®ner Ã  la rÃ©cursion avancÃ©e et DP.

---

## ðŸŸ¦ Semaine 8 â€” Consolidation & Design
**Skiena : Chapitre 9â€“10 (pages ~316â€“356)**

- Intractable Problems, P vs NP
- Algorithm Design Strategies
- Exercises rapides

**LeetCode :**
- [ ] 155. Min Stack
- [ ] 380. Insert Delete GetRandom O(1)
- [ ] 225. Implement Stack using Queues
- [ ] 146. LRU Cache
- [ ] 10. Regular Expression Matching (challenge)

**Objectif :**
- Consolider la reconnaissance des patterns et le design dâ€™algorithmes.

---

### ðŸ“Œ Notes
- Lire + coder **immÃ©diatement aprÃ¨s lecture**.
- Prioriser la **comprÃ©hension des patterns**, pas la mÃ©morisation.
- Les chapitres avancÃ©s (geometrie, FFT, cryptography) = rÃ©fÃ©rence pour plus tard.
